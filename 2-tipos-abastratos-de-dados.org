#+STARTUP: showall align
#+OPTIONS: todo:nil tasks:all tags:nil
#+AUTHOR: Manoel Vilela
#+TITLE: Estrutura de Dados @@latex:\\@@ 02 - Tipos Abstratos de Dados
#+DATE: <2017-08-29 Tue 20:16>
#+EXCLUDE_TAGS: TOC_3
#+LANGUAGE: bt-br
#+LATEX_HEADER: \usepackage[]{babel}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \renewcommand\listingscaption{Código}

* Sumário                                                             :TOC_3:
:PROPERTIES:
:CUSTOM_ID: toc-org
:END:
- [[#resumo][Resumo]]
- [[#in-progress-exemplos-de-tipos-abstratos-de-dados][IN-PROGRESS Exemplos de Tipos Abstratos de Dados]]
  - [[#point][Point]]
  - [[#in-progress-circle][IN-PROGRESS Circle]]
  - [[#matrix][Matrix]]
- [[#referências][Referências]]

* Resumo

Na aula de hoje foi comentado sobre a ideia mais primitiva que se conhece sobre
orientação a objetos, antes mesmo desse paradigma ser famoso como hoje. Encapsulamento via
Tipos Abstratos de Dados.

A ideia principal é criar uma estrutura e seus métodos que a manipulam de forma isolada e encapsulada.
Para uma estrutura chamada ~Ponto~ por exemplo, é possível definir um arquivo ~ponto.h~ que recebe
todas suas declarações e um arquivo ~ponto.c~ que definirá essas declarações, seja da estrutura e seus métodos.

Usualmente o arquivo ~ponto.h~ serve para ser incluso em outro arquivo que usará essa estrutura,
geralmente um outro programa por exemplo ~main.c~ então passar informações que essas funções deverão
ser ligadas no processo de /linking/ para então gerar um binário.

De uma maneira geral, o processo de compilação para projetos estruturados com TAD, compila-se todos códigos
objetos com ~gcc -c ponto.c main.c~ gerando arquivos ~ponto.o~ e ~main.o~ então se faz a ligação deles com
o comando ~gcc -o main.out ponto.o main.o~.

A principal ideia de uma estrutura dessa é o poder de encapsular implementações e reduzir a complexidade de código
disponível para o programador numa determinada camada, criando interfaces para manipular estruturas em níveis sucessivos
de abstração.

Houve um tópico adicional no final da aula sobre complexidade de algoritmos, mas isso vou deixar para outro arquivo.

* IN-PROGRESS Exemplos de Tipos Abstratos de Dados
  SCHEDULED: <2017-08-31 Thu>

Estarei descrevendo nos próximos tópicos três implementações de TAD:

- Point
- Circle
- Matrix

** DONE Point
   CLOSED: [2017-09-05 Tue 00:13]

Os métodos necessários para manipular um ponto é definido como:

#+NAME: point:header
#+CAPTION: Cabeçalho da TAD Point definido em point.h.
#+BEGIN_SRC c
  /**
   ,* @brief struct Point as 2D space pointer
   ,*/
  typedef struct point Point;

  /**
   ,* @brief create a new Point and set x an y
   ,*
   ,* @return the address of the allocated point
   ,*/
  Point* point_create(float x, float y);

  /**
   ,* @brief free memory for the Point p
   ,* @param p Point to be free
   ,*/
  void point_free(Point *p);

  /**
   ,* @brief Set the values of p.x and p.y
   ,*/
  void point_set(Point *p, float x, float y);

  /**
   ,* @brief Get the values of p.x and p.y through the pointers *x and *y
   ,*/
  void point_get(Point *p, float *x, float *y);

  /**
   ,* @brief calculate the euclidean distance between two points
   ,*
   ,* @return the distance of *px and *py as a float number
   ,*/
  float point_distance(Point *px, Point *py);
#+END_SRC

A implementação é totalmente escondida e provida pelo arquivo =point.c=.
É possível encontrá-lo em [[src/tad/point/point.c][point.c]]

** IN-PROGRESS Circle

A implementação do /Circle/ é através do uso da TAD /Point/.
Os métodos relacionados a essa TAD é descrito como:

#+NAME: circle:header
#+CAPTION: Cabeçalho da TAD Circle definido em circle.h
#+BEGIN_SRC c
  /**
   ,* @brief define a Circle structure
   ,*/
  typedef struct circle Circle;

  /**
   ,* @brief allocate a new circle on memory based on its parameters
   ,*/
  Circle* circle_create(Point *center, float radius);

  /**
   ,* @brief free memory allocated by the circle c
   ,*/
  void circle_free(Circle *c);

  /**
   ,* @brief Set the values of center and radius of structure
   ,*/
  void circle_set(Circle *c, Point *center, float radius);

  /**
   ,* @brief Get the its internal attributes through the pointers passed
   ,*/
  void circle_get(Circle *c, Point *center, float *radius);

  /**
   ,* @brief Check if the pointer /p point is inside of the circle
   ,*/
  int circle_point_inside(Circle *c, Point *point);
#+END_SRC

Ou seja, temos estes 5 métodos relacionado a manipulação do dado /Circle/.
Foram omitidos nessa amostra as declarações dos seguintes métodos:

- =circle_set_radius=
- =circle_set_center=
- =circle_get_radius=
- =circle_get_center=

Já que estes métodos são apenas açúcar sintático para os métodos circle_get
e circle_set.
** TODO Matrix

<definir assinaturas>


* Referências

- CELES; WALDEMAR, 2004, Introdução a Estrutura de Dados, Capitulo 9, p.123
