#+STARTUP: showall align
#+OPTIONS: todo:nil tasks:all tags:nil
#+AUTHOR: Manoel Vilela
#+DATE: <2017-08-22 Tue 22:16>
#+TITLE: Estrutura de Dados @@latex:\\@@ 01 - Matrizes e Tipos Estruturados
#+EXCLUDE_TAGS: TOC_3
#+LANGUAGE: bt-br
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage[]{babel}

* Sumário                                                             :TOC_3:
:PROPERTIES:
:CUSTOM_ID: toc-org
:END:
- [[#resumo][Resumo]]
- [[#struct-notações-e-armazenamento][Struct, notações e armazenamento]]
- [[#typedef][Typedef]]
- [[#estrutura-círculo][Estrutura Círculo]]

* Resumo

Nessa aula terminamos de ver os tipos de alocação de matrizes e também foi comentado
através de uma pergunta que fiz sobre as implicações de uso, tal como eficiência.
No caso da alocação de uma matriz por ponteiros a resolução de referência é dupla, pois
é necessário primeiro pegar o endereço da linha e depois com o índice da coluna
o valor da posição (i,j). Por outro lado, na alocação de matriz por vetor o acesso é único,
pois após a transformação dos índices, estamos nada mais que acessando um elemento de um único vetor.
Isso pode ser relevante em sistemas críticos que há uma frequência de acesso das estruturas muito alto.


Na outra parte da aula, tivemos introdução a "Tipos Estruturados de Dados". Ou, simplesmente,
TAD (Tipos Abstratos de Dados) — em inglês conhecido como /Abstract Data Types/. Tipos estruturados
nada mais são que tipos compostos por tipos primitivos da linguagem ou outros tipos estruturados já definidos. Por exemplo,
um muito simples é o ponto euclidiano:

#+BEGIN_SRC c
struct Ponto {
   int x;
   int y;
};

#+END_SRC


Os tópicos que foram dados se resume a:

1. Criar estruturas em C através da keyword ~struct~;
2. A notação de ponto para estruturas;
3. Notação de seta para ponteiros de estruturas;
4. Como um ~struct~ é armazenada em memória;
5. Uso de ~typedef~ pra criar /aliases/ para tipos.
6. Exemplos variados dos tópicos acima.


* Struct, notações e armazenamento

Uma estrutura é um dado composto por um ou mais dados primitivos (ou outras estruturas),
onde pode se armazenar diferente tipos de dados num mesmo bloco de memória (contígua).

Como demonstrado anteriormente com o exemplo do ~struct Ponto~, dois membros são declarados
como ~x~ e ~y~. Estruturas são semelhantes a vetores no sentido de armazenamento, esses membros
são armazenados lado a lado e o acesso de futuros membros são determinados pelo seu tipo.

Necessariamente, o endereço de uma estrutura é o endereço do seu primeiro membro (nesse caso ~x~). O
que ocorria de maneira semelhante com os vetores. Para o acesso dos seus membros é usado a notação
de ponto, como segue o exemplo:

#+BEGIN_SRC c
  int main(void) {
    struct Ponto p;
    p.x = 10;
    p.y = 20;

  }
#+END_SRC

A ordem de acesso é determinística por conta que a ordem da declaração dos membros no /struct/ importa.
A partir do tamanho que cada tipo armazenará, o compilador determina a quantidade de passos necessário a ser
feito pra chegar ao endereço do próximo membro.

Como fim de apenas uma simple facilidade, isto é, um açúcar sintático, é provida uma sintaxe alternativa
para a manipulação de estrutura de ponteiros.
De forma equivalente ~(*pp).x~ é igual a ~pp->x~, sendo ~pp~ uma variável do tipo ~struct *Ponto~.

* Typedef

Typedef é criado como uma forma de /alias/ para tipos já definidos.

#+BEGIN_SRC c
  typedef int StudentId;

  typedef struct {
      int x;
      int y;
  } Ponto;

#+END_SRC

O struct anônimo acima é uma maneira mais simples de definir um novo tipo. No entanto, o usuário
ainda se quiser poderá declarar a estrutura separadamente, assim como também declarar junto e passar o nome da estrutura
ou não.

#+BEGIN_SRC c
  struct Ponto {
      int x;
      int y;
  };

  typedef struct Ponto Ponto;

  typedef struct _Ponto {
      int x;
      int y;
  } _Ponto;
#+END_SRC

* DONE Estrutura Círculo
  CLOSED: [2017-08-29 Tue 00:54] SCHEDULED: <2017-08-25 Fri>

Estarei escrevendo alguns exemplos dado em sala no diretório [[file:src/circle/]].


Em geral eu defini os arquivos as estruturas:

- Point
- Circle

Alguns métodos adicionais foram feitos pra facilitar a estrutura, como
=new_point()=, =new_circle()=, =read_point()= e =read_circle()=.

A estrutura de arquivos é dada como:

#+BEGIN_EXAMPLE
src/circle
    => Makefile
    => circle.c
    => circle.h
    => point.c
    => point.h
    => pause.h
    => main.c
#+END_EXAMPLE

Em geral os /headers/ (arquivos terminados com =.h=) contém apenas declarações das estruturas
e de seus métodos. Adicionalmente, o cabeçalho =pause.h= possui algumas definições para ser fácil
de importado. Eu escrevi esse cabeçalho para possuir um método portável de chamar uma função /pause/,
já que isto possa às vezes ser necessário quando executado no Windows — pois é uma prática
comum nesse sistema o usuário apenas clicar no executável, então abrir uma janela de terminal que fecha após o program ser
finalizado (necessitando pausar a aplicação pra observar a saída).


As principais estruturas definidas respectivamente em =point.h= e =circle.h= são:


#+BEGIN_SRC c
  typedef struct {
      float x;
      float y;
  } Point;


  typedef struct {
      Point center;
      float r
  } Circle;

#+END_SRC

Da qual a primeira representa um ponto no plano euclidiano e a segunda um círculo. Os seus principais
métodos são =float distance(Point *px, Point *py)= e =int point_inside(Circle *c, Point *p)=. Para
mais informações, por favor, olhe as definições no código fonte de cada estrutura (=point.c= e =circle.c=).
O código é legível e documentado.
